package pspud_gen;

/*
 * Created on Jun 29, 2004
 *
 */

/**
 * @author Minh
 *
 */

import edu.asu.sapa.parsing.*;
import edu.asu.sapa.basic_ds.*;

import java.io.*;
import java.util.*;

import java.text.*;

import edu.asu.sapa.parsing.PDDL21Parser;

// a size (number of elements of the set of dependencies)
// lower and upper bounds of the indices of goals

// takes a list of sizes

public class ZenoTravel_Gen {
	public void generate(Domain domain, Problem problem, long seed,
			String probFileName) {
		int i, j;
		Random random = new Random(seed);
		NumberFormat formatter = new DecimalFormat("0.00");

		String PSPFileName = new String(probFileName + "_psp");

		System.out
				.println("\n******* Generator for PSP_UD version of ZenoTravel Domain ********");
		System.out.println("domain: " + domain.getName() + " | problem: "
				+ problem.getName() + " | random-seed = " + seed);
		System.out.println("Input Problem File: " + probFileName
				+ " | Output PSP File: " + PSPFileName);

		try {
			FileWriter out = new FileWriter(PSPFileName, false);
			out.write(";; Automatically generated by ZenoTravel_Gen\n"
					+ ";; Original problem file: " + probFileName
					+ " | Random Seed:");
			out.write(seed + "\n");

			// Output to file portions in the original file. Shared for all
			// domains
			out.write("(define (problem " + problem.getName() + ")\n");
			out.write("(:domain " + domain.getName() + ")\n");
			out.write("(:objects\n");

			String type;
			ArrayList objects;
			for (i = 0; i < problem.numObjectType(); i++) {
				type = problem.getObjectType(i);
				objects = problem.getObjectMap(type);

				out.write("\t");
				for (j = 0; j < objects.size(); j++)
					out.write((String) objects.get(j) + " ");
				out.write("- " + type + "\n");
			}

			// Original initial predicates and functions
			out.write(")\n(:init\n");
			Predicate pred;
			for (i = 0; i < problem.numInitPred(); i++) {
				pred = problem.getInitPred(i);

				out.write("\t(" + pred.getName());
				for (j = 0; j < pred.predSize(); j++)
					out.write(" " + pred.getObj(j));
				out.write(")\n");
			}
			out.write("\n");

			Function func;
			for (i = 0; i < problem.numInitFunct(); i++) {
				func = problem.getInitFunct(i);
				if (func.getName().toLowerCase().equals("boarding-time")
						|| func.getName().toLowerCase()
								.equals("debarking-time"))
					continue;

				out.write("\t(= (" + func.getName());
				for (j = 0; j < func.funcSize(); j++)
					out.write(" " + func.getObj(j));
				out.write(") " + func.getValue() + ")\n");
			}

			/**
			 * Speciallized for ZenoTravel domain. Generate
			 */
			ArrayList aircraftList = problem.getObjectMap("aircraft");
			ArrayList cityList = problem.getObjectMap("city");
			ArrayList personList = problem.getObjectMap("person");

			System.out
					.println("\n (boarding-time ?city) : 0.5hr - 2hr (random)");
			out.write("\n\t;; (boarding-time ?c): [0.5hr - 2.0hr] (random)\n");
			float randFloat;
			for (i = 0; i < cityList.size(); i++) {
				out.write("\t(= (boarding-time " + (String) cityList.get(i)
						+ ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(0.5 + (2.0 - 0.5) * randFloat)
						+ ")\n");
			}

			System.out
					.println(" (debarking-time ?city) : 0.25hr - 1hr (random)");
			out
					.write("\n\t;; (debarking-time ?c): [0.25hr - 1.0hr] (random)\n");
			for (i = 0; i < cityList.size(); i++) {
				out.write("\t(= (debarking-time " + (String) cityList.get(i)
						+ ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(0.25 + (1.0 - 0.25) * randFloat)
						+ ")\n");
			}

			System.out
					.println(" (labor-cost ?city) : 5USD-10USD/hour (random)");
			out.write("\n\t;; (labor-cost ?c): [5USD - 10USD/hour] (random)\n");
			for (i = 0; i < cityList.size(); i++) {
				out
						.write("\t(= (labor-cost " + (String) cityList.get(i)
								+ ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(5 + (10 - 5) * randFloat) + ")\n");
			}

			System.out
					.println(" (fuel-cost ?city) : 0.1USD-0.3USD/litte (random)");
			out
					.write("\n\t;; (fuel-cost ?c): [0.1USD-0.3USD/litte] (random)\n");
			for (i = 0; i < cityList.size(); i++) {
				out.write("\t(= (fuel-cost " + (String) cityList.get(i) + ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(0.1 + (0.3 - 0.1) * randFloat)
						+ ")\n");
			}

			System.out
					.println(" (airport-fee ?city): 7USD-15USD/person (random)");
			out
					.write("\n\t;; (airport-fee ?c): [7USD-15USD/person] (random)\n");
			for (i = 0; i < cityList.size(); i++) {
				out.write("\t(= (airport-fee " + (String) cityList.get(i)
						+ ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(7 + (15 - 7) * randFloat) + ")\n");
			}

			System.out
					.println(" (aiport-aircraft-fee ?plane ?city): 25USD-50USD/plane (random)");
			out
					.write("\n\t;; (airport-aircraft-fee ?plane): [25USD - 50USD/plane] (random)\n");
			for (i = 0; i < aircraftList.size(); i++) {
				for (j = 0; j < cityList.size(); j++) {
					out.write("\t(= (airport-aircraft-fee "
							+ (String) aircraftList.get(i) + " "
							+ (String) cityList.get(j) + ") ");
					randFloat = random.nextFloat();
					out.write(formatter.format(25 + (50 - 25) * randFloat)
							+ ")\n");
				}
			}

			System.out.println(" (maintainance-cost ?plane): 0.1 - 0.25USD/mi");
			out.write("\n\t;; (maintainance-cost ?plane): 0.1 - 0.25USD/mi\n");
			for (i = 0; i < aircraftList.size(); i++) {
				out.write("\t(= (maintainance-cost "
						+ (String) aircraftList.get(i) + ") ");
				randFloat = random.nextFloat();
				out.write(formatter.format(0.1 + (0.25 - 0.1) * randFloat)
						+ ")\n");
			}

			out.write(")\n(:goal (and\n");

			// Output the new goal format
			System.out
					.println(" Goals: (at ?plane ?city) - soft | (at ?person ?city) 80% soft");
			System.out
					.println(" Goal utility: random with bounds [10000 - 16000]");
			out
					.write("\t;; Goals: (at ?plane ?city) - soft | (at ?person ?city) 80% soft\n");
			out
					.write("\t;; Goal utility: random with bounds [10000 - 16000]\n");
			String obj;
			for (i = 0; i < problem.numGoal(); i++) {
				pred = problem.getGoal(i).gID;
				obj = pred.getObj(0);

				out.write("\t((at");
				out.write(" " + obj + " " + pred.getObj(1) + ")");
				if (aircraftList.contains(obj)) { // Is aircraft (not person)
					out.write(" soft ");
					aircraftList.remove(aircraftList.indexOf(obj));

					out.write(formatter.format(10000 + (16000 - 10000)
							* random.nextFloat())
							+ ")\n");
				} else {
					if (random.nextFloat() > 0.2) {
						out.write(" soft ");
						out.write(formatter.format(10000 + (16000 - 10000)
								* random.nextFloat())
								+ ")\n");
					} else {
						out.write(" hard ");
						// Double the utility values for "hard" goals.
						out.write(formatter.format(2 * (10000 + (16000 - 10000)
								* random.nextFloat()))
								+ ")\n");
					}
					personList.remove(personList.indexOf(obj));
				}
			}

			/*
			 * Add goals to person/airplane that do not appear in the original
			 * goal list. All additional goals are soft
			 */
			int cityIndex;
			ArrayList newGoals = new ArrayList();
			if (aircraftList.size() > 0 || personList.size() > 0) {
				System.out
						.println(" Remain goals: (at ?obj ?city) - soft | utility: [1000-5000]");
				out
						.write("\n\t;; Additional goals. Utility: 1000-5000 (random). All Soft.\n");
				for (i = 0; i < personList.size() && i < 20; i++) {
					out.write("\t((at " + (String) personList.get(i));
					// Randomly select the city
					cityIndex = random.nextInt(cityList.size());
					out.write(" "
							+ (String) cityList.get(cityIndex)
							+ ") soft "
							+ formatter.format(1000 + (5000 - 1000)
									* random.nextFloat()) + ")\n");

					pred = new Predicate();
					pred.setName("at");
					pred.addObj((String) personList.get(i));
					pred.addObj((String) cityList.get(cityIndex));

					newGoals.add(pred);
				}

				for (i = 0; i < aircraftList.size() && i < 20; i++) {
					out.write("\t((at " + (String) aircraftList.get(i));
					// Randomly select the city
					cityIndex = random.nextInt(cityList.size());
					out.write(" "
							+ (String) cityList.get(cityIndex)
							+ ") soft "
							+ formatter.format(1000 + (5000 - 1000)
									* random.nextFloat()) + ")\n");

					pred = new Predicate();
					pred.setName("at");
					pred.addObj((String) aircraftList.get(i));
					pred.addObj((String) cityList.get(cityIndex));

					newGoals.add(pred);
				}
			}

			/*
			 * Goal utility dependencies: ({g1 g2 g3... gn} util-value)
			 */
			for (i = 0; i < problem.numGoal(); i++) {
				newGoals.add(problem.getGoal(i).gID);
			}

			int udSize, gIndex = -1, numG = newGoals.size();
			ArrayList uds = new ArrayList(); // store generated uds for
			// duplicate detection
			if (numG >= 2) {
				// int numUD = random.nextInt(maxNumGUD(numG));
				int numUD = Math.min(random.nextInt(10) + 5, (int) Math.pow(2,
						numG)
						- (numG + 1));
				System.out.println("num goal dep: " + numUD);
				ArrayList selected = new ArrayList();
				System.out
						.println(" Goal Dependencies (random):\n\t n = [0,min(3*|G|,2^|G|-(|G|+1)], size = [2,numG], u=[-10000,10000]");
				out
						.write("\n\t;; Goal Dependencies (random):\n\t;; n = [0,x=min(3*|G|,2^|G|-(|G|-1)], size = [2,numG], u=[-10000,10000]\n");
				for (i = 0; i < numUD; i++) {
					udSize = 2 + random.nextInt(numG - 2);
					selected.clear();
					for (j = 0; j < udSize; j++) {
						while (true) {
							gIndex = random.nextInt(numG);
							if (!selected.contains(new Integer(gIndex))) {
								selected.add(new Integer(gIndex));
								break;
							}
						}
					}

					if (notGenerated(uds, selected)) {
						out.write("\t({");
						uds.add(new ArrayList(selected));
						for (int k = 0; k < udSize; k++) {
							gIndex = ((Integer) selected.get(k)).intValue();
							pred = (Predicate) newGoals.get(gIndex);
							out.write("(at " + pred.getObj(0) + " "
									+ pred.getObj(1) + ") ");
						}
						float value;
						int negChance = random.nextInt(2);
						// if (negChance == 1) { // negative
						if (i < numUD / 2) {
							value = -(10000 + (20000 - 10000)
									* random.nextFloat());
						} else {
							value = 4000 + (10000 - 4000) * random.nextFloat();
						}

						out.write("} " + formatter.format(value) + ")\n");

					}
				}
			}

			out.write("\t)\n");
			out.write("))\n");

			out.flush();
			out.close();
		} catch (IOException e) {
			System.err.println(e);
		}
	}

	/**
	 * Return the upper-bound on the number of goal utility dependencies.
	 * min(3*numG, n=2^|G|-(|G|+1)) with n is the number of possible goal set of
	 * size >= 2.
	 */
	private int maxNumGUD(int numG) {
		return (int) Math.min(3 * numG, Math.pow(2, numG) - (numG + 1));
	}

	/**
	 * check fi ud is already generated and stored in uds
	 * 
	 * @return
	 */
	private boolean notGenerated(ArrayList uds, ArrayList ud) {
		ArrayList tempUD;
		int i, j;
		for (i = 0; i < uds.size(); i++) {
			tempUD = (ArrayList) uds.get(i);
			if (tempUD.size() == ud.size()) {
				for (j = 0; j < ud.size(); j++)
					if (!tempUD.contains(ud.get(j)))
						break;
				if (j == ud.size())
					return false;
			}
		}
		return true;
	}

	/**
	 * Main program that call the parsers to read in the domain and problem
	 * files in PDDL2.1 then call the generator program to generate the new PSP
	 * Problem file.
	 * 
	 * @param args
	 */

	public static void main(String args[]) {
		PDDL21Parser parser21 = new PDDL21Parser(System.in);
		ZenoTravel_Gen ztGen = new ZenoTravel_Gen();
		System.out.println(";; " + System.getProperty("user.dir"));

		Domain domain;// = new Domain();
		Problem prob;// = new Problem();

		FileInputStream pddl_file;

		/*
		 * Instantiate a parser
		 */

		if (args.length != 3) {
			System.out
					.println("Usage: java ZenoTravel_Gen <domain> <problem> <random-seed>");
			return;
		}

		/** * Parse the Domain specification file *** */
		try {
			pddl_file = new java.io.FileInputStream(args[0]);
			PDDL21Parser.ReInit(pddl_file);
		} catch (java.io.FileNotFoundException e) {
			System.out.println("Domain file " + args[0] + " not found !!!");
			return;
		}

		try {
			domain = PDDL21Parser.parse_domain_pddl();
			System.out.println(";;Domain file succesfully read !!"
					+ " num actions = " + domain.numAction());
		} catch (Exception e) {
			System.out.println("Exception while parsing domain file!!");
			e.printStackTrace();
			return;
		}

		/** ** Parse the problem file *** */
		try {
			pddl_file = new java.io.FileInputStream(args[1]);
			PDDL21Parser.ReInit(pddl_file);
		} catch (java.io.FileNotFoundException e) {
			System.out.println("Problem file " + args[1] + " not found !!!");
			return;
		}

		try {
			prob = PDDL21Parser.parse_problem_pddl();
			System.out.println(";;Problem file succesfully read !!");
		} catch (Exception e) {
			System.out.println("Exception while parsing problem file!!");
			e.printStackTrace();
			return;
		}

		/** * Read the random seed (integer) *** */
		long seed = (new Long(args[2])).longValue();

		ztGen.generate(domain, prob, seed, args[1]);
	}
}
